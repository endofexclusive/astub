# Introduction

This directory contains an example target application which can be used
together with *astub* built for the *Commodore Amiga A500*. Following sections
describes how it can be started and debugged using both hardware and emulator.


# Requirements

- A *m68k* toolchain. Parent directory `README.md` file describes how it can be
  built.
- *socat* (Install with `# apt-get install socat` or similar.)
- *FS-UAE* Amiga emulator and a Kickstart ROM.
- A *Commodore Amiga* computer (target) with *Motorola MC68000* processor and
  at least 512 KiB RAM.
- A serial connection between the target and the host.


# Building the example application

To build the example, run `make` in this directory:

    $ make
    m68k-elf-gcc -MT ex1.o -MMD -MP -MF .d/ex1.Td -march=68000 -fomit-frame-pointer -g -Os -mpcrel -mshort -Wall -Wextra -std=gnu99 -pedantic -I../../include -c -o ex1.o ex1.c
    mv -f .d/ex1.Td .d/ex1.d
    vasmm68k_mot -quiet -phxass -m68000 -Felf  -o head.o head.s
    m68k-elf-gcc -nostdlib ex1.o head.o -T ex1.ld -o ex1 -Wl,-Map=ex1.map
    m68k-elf-objdump -d ex1 > ex1.asm
    m68k-elf-size head.o ex1.o -t --common
       text    data     bss     dec     hex filename
         46       0       0      46      2e head.o
         80       0       0      80      50 ex1.o
        126       0       0     126      7e (TOTALS)
    m68k-elf-size ex1
       text    data     bss     dec     hex filename
        128       0       0     128      80 ex1
    $

The following output files are generated:

- `ex1` is the ELF file to load with *GDB*.
- `ex1.asm` is a disassembly of `ex1`.
- `ex1.map` is a memory map file for `ex1` generated by the linker.


# Running on *Amiga* hardware

Before the host can connect to the target (*Amiga* computer), the program
*astub* must be loaded on the target. Copy the file `../build/astub` to an
*Amiga* floppy disk and start it, prefereable via `s:startup-sequence`.

Now when the target computer has loaded *astub*, make the `gdbhw` target on the
host:

    $ make gdbhw
    make: *** No rule to make target 'pty_gdbhw', needed by 'gdbhw'.  Stop.

There is a dependency on the file `pty_gdbhw` which is the communication
channel to the target. Create a symbolic link to the corresponding *tty file*.
For example, if the *tty* is named `/dev/ttyUSB0`:

    $ ln -s /dev/ttyUSB0 pty_gdbhw

Now try the `gdbhw` target again:

    $ make gdbhw 
    make -C ../../amiga/build
    make[1]: Entering directory '/home/asdf/repos/astub/amiga/build'
    make[1]: Nothing to be done for 'all'.
    make[1]: Leaving directory '/home/asdf/repos/astub/amiga/build'
    cp ../../amiga/build/astub fs
    m68k-elf-gdb ex1 -ex "target remote pty_gdbhw" -b 230400 -x gdb.script
    GNU gdb (GDB) 7.10.1
    Copyright (C) 2015 Free Software Foundation, Inc.
    License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
    This is free software: you are free to change and redistribute it.
    There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
    and "show warranty" for details.
    This GDB was configured as "--host=x86_64-unknown-linux-gnu --target=m68k-elf".
    Type "show configuration" for configuration details.
    For bug reporting instructions, please see:
    <http://www.gnu.org/software/gdb/bugs/>.
    Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.
    For help, type "help".
    Type "apropos word" to search for commands related to "word"...
    Reading symbols from ex1...done.
    Remote debugging using pty_gdbhw
    0x0007f866 in ?? ()
    $1 = ""
    $2 = "Use 'load', then 'cont' to start the target application.  'detach' can be used"
    $3 = "before exit."
    (gdb)

*BINGO!* Now load and start the example:

    (gdb) load
    Loading section .text, size 0x80 lma 0x400
    Start address 0x400, load size 128
    Transfer rate: 5 KB/sec, 64 bytes/write.
    (gdb) cont
    Continuing.

For information on the *GDB* source-level debugging features, see the *GDB*
documentation. (For example: break execution with `CTRL+C`, step with `step`,
step one instruction with `stepi`, continue execution with `cont`, insert
breakpoints with `break`, insert watchpoints with `watch`, etc.)

You can of course use your favourite *GDB* frontend, like *ddd* or *Eclipse*.
*GDB tui* can be started by entering `-` at the `(gdb)` prompt. Command `tui
reg` is also interesting.

NOTE: For the full source-level control, compile the example program without
optimization by modifying the `Makefile`: replace `CFLAGS` parameter `-Os` with
`-O0`.


## Symbol debugging

Here is an example on how the symbols in the source code can be used to read
the *Amiga* custom registers. The *GDB* command `set debug remote 1` activates
messages on what is happening on the remote protocol. We read the register
`VHPOSR` (vertical and horizontal position of beam or light pen).

    (gdb) set debug remote 1
    (gdb) whatis VHPOSR
    type = const volatile uint16_t * const
    (gdb) print VHPOSR
    $3 = (const volatile uint16_t * const) 0xdff006
    (gdb) print/x *VHPOSR
    Sending packet: $mdff006,2#91...Ack
    Packet received: 8cc2
    $4 = 0x8cc2
    (gdb) x/h VHPOSR
    Sending packet: $mdff006,2#91...Ack
    Packet received: e6ca
    0xdff006:       0xe6ca
    (gdb)

Custom registers can be written like the following example, where color
register 0 is set to `0x00f0`.

    (gdb) set *COLOR0 = 0x00f0
    Sending packet: $Mdff180,2:00f0#a4...Ack
    Packet received: OK
    Sending packet: $g#67...Ack
    Packet received: ffffffd30000000100001065000018340000000100008cf500004ecf000238640000048000000480000238c8000238c8000238ba00dff0000003fffc0003ffec0000200b0000045a
    (gdb)

There is currently a limitation with this. The *MC68000* architecture part of
*astub* always processes the `M` command by writing bytes, and the `m` command
always reads bytes. The Amiga chipset architecture requires word (16-bit) bus
writes to operate correctly. This could be fixed by changing the command
interpreter for `M` such that it investigates the target address and performs
word write if it falls into the custom chip area. Furthermore, a read with `m`
to a write-only register should not be allowed.

We can also see from the example above how the CPU registers are read back
after the custom hardware write. Reason is unknown.


# Running on emulator

To run the example with the emulator *FS-UAE*, first create the pseudo terminal
files `pty_gdbsim` and `pty_sim` by running the script `tacos.sh`:

    $ ./tacos.sh

Then in another terminal, start *FS-UAE* by making the `sim` target:

    $ make sim

In third terminal, connect with *GDB* using the `gdbsim` target.

    $ make gdbsim

Then everything should be similar as when working with a hardware target.

- NOTE: `tacos.sh` script must be run before `make sim`. Otherwise *FS-UAE*
  will not open the pseudo terminal.
- NOTE: `make sim` expects a file named `ks` containing the Kickstart ROM
  image.
- NOTE: `make sim` must be issued before `make gdbsim`. Otherwise the emulated
  system will crash. (This does not happen when starting *GDB* before *astub*
  on hardware however.)

